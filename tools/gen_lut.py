#!/usr/bin/env python3
"""
Generate a 256-entry sRGB -> linear float32 lookup table suitable for embedding
directly into Zig (or C/C++/Rust/etc).

Definition (IEC 61966-2-1):

Let v = 8-bit sRGB sample / 255.0
If v <= 0.04045:
    linear = v / 12.92
Else:
    linear = ((v + 0.055) / 1.055) ** 2.4

We emit a table of f32 literals with configurable precision.

Usage:
  python gen_lut.py                  # default (prints Zig array)
  python gen_lut.py --lang zig       # explicit (same as default)
  python gen_lut.py --lang c         # emit C style
  python gen_lut.py --precision 10   # digits after decimal
  python gen_lut.py --type f32       # element type (zig) or 'float'
  python gen_lut.py --no-trailing    # omit trailing comma on last element
  python gen_lut.py --header "const SRGB_LUT"  # change symbol name
  python gen_lut.py --minimize       # remove line breaks (single line)

Example integration (Zig):
    const SRGB_LUT: [256]f32 = .{
        // generated by tools/gen_lut.py
        0.0, 0.0003035269835, ...
    };

Why generate instead of runtime?
 - Eliminates startup cost (tiny but measurable in hot micro-bench loops)
 - Avoids compile-time branch quotas if using math.pow in a @compileTime loop
 - Guarantees consistent rounding across platforms

Author: (auto-generated script)
"""

from __future__ import annotations
import argparse
import math
import sys
from typing import List


def srgb_to_linear(v: float) -> float:
    if v <= 0.04045:
        return v / 12.92
    return ((v + 0.055) / 1.055) ** 2.4


def build_table(precision: int) -> List[str]:
    fmt = f"{{:.{precision}f}}"
    out: List[str] = []
    for i in range(256):
        v = i / 255.0
        lin = srgb_to_linear(v)
        # Clamp minor negatives due to floating rounding
        if lin < 0 and lin > -1e-15:
            lin = 0.0
        # Represent exact 0 and 1 nicely
        if i == 0:
            out.append("0.0")
        elif i == 255:
            out.append("1.0")
        else:
            out.append(fmt.format(lin).rstrip("0").rstrip(".") if precision > 0 else fmt.format(lin))
    return out


def emit_zig(table: List[str], elem_type: str, header: str, trailing: bool, minimize: bool) -> str:
    comment = "// Generated by tools/gen_lut.py (sRGB -> linear)"
    open_line = f"{header}: [256]{elem_type} = .{{"
    close_line = "};"
    elems: List[str] = []
    for idx, val in enumerate(table):
        comma = "," if (trailing or idx < 255) else ""
        elems.append(f"{val}{comma}")
    if minimize:
        body = " ".join(elems)
        return f"{comment}\n{open_line}{body}{close_line}\n"
    # Multi-line with 16 per line for readability
    lines = []
    per_line = 16
    for i in range(0, 256, per_line):
        slice_part = elems[i : i + per_line]
        lines.append("    " + " ".join(slice_part))
    return f"{comment}\n{open_line}\n" + "\n".join(lines) + f"\n{close_line}\n"


def emit_c(table: List[str], elem_type: str, header: str, trailing: bool, minimize: bool) -> str:
    comment = "/* Generated by tools/gen_lut.py (sRGB -> linear) */"
    open_line = f"{elem_type} {header}[256] = {{"
    close_line = "};"
    elems: List[str] = []
    for idx, val in enumerate(table):
        comma = "," if (trailing or idx < 255) else ""
        # Ensure decimal for floats
        if "." not in val and "e" not in val and "E" not in val:
            val = val + ".0"
        elems.append(f"{val}f{comma}")
    if minimize:
        body = " ".join(elems)
        return f"{comment}\n{open_line}{body}{close_line}\n"
    lines = []
    per_line = 8
    for i in range(0, 256, per_line):
        slice_part = elems[i : i + per_line]
        lines.append("    " + " ".join(slice_part))
    return f"{comment}\n{open_line}\n" + "\n".join(lines) + f"\n{close_line}\n"


def main(argv: List[str]) -> int:
    ap = argparse.ArgumentParser(add_help=True)
    ap.add_argument("--lang", choices=["zig", "c"], default="zig", help="Output style.")
    ap.add_argument("--precision", type=int, default=10, help="Digits after decimal (default: 10).")
    ap.add_argument("--type", dest="elem_type", default="f32", help="Element type: zig f32 / C float, etc.")
    ap.add_argument("--header", default="SRGB_LUT", help="Symbol name / left-hand side.")
    ap.add_argument("--no-trailing", action="store_true", help="Omit trailing comma on last element.")
    ap.add_argument("--minimize", action="store_true", help="Single-line mode.")
    args = ap.parse_args(argv)

    if args.precision < 0 or args.precision > 20:
        print("Precision must be between 0 and 20.", file=sys.stderr)
        return 2

    table = build_table(args.precision)
    trailing = not args.no_trailing

    if args.lang == "zig":
        sys.stdout.write(emit_zig(table, args.elem_type, args.header, trailing, args.minimize))
    else:
        # For C, map default type if user left zig-specific default
        elem_type = args.elem_type
        if elem_type == "f32":
            elem_type = "float"
        sys.stdout.write(emit_c(table, elem_type, args.header, trailing, args.minimize))

    return 0


if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))